name: Atlas CI
on:
  pull_request:
    paths:
      - 'src/db/schema/**'
      - 'atlas.hcl'

permissions:
  contents: read
  pull-requests: write

jobs:
  schema-check:
    name: Schema Diff Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: yarn install

      - uses: ariga/setup-atlas@v0

      - name: Check Schema Diff
        id: diff
        env:
          NEON_DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        run: |
          # atlas schema apply --dry-run ã§ Neon ã®ç¾åœ¨ã®çŠ¶æ…‹ã¨ã®å·®åˆ†ã‚’å–å¾—
          DIFF=$(atlas schema apply \
            --env neon \
            --dry-run 2>&1) || true

          # "Schema is synced" ã®å ´åˆã¯å¤‰æ›´ãªã—
          if echo "$DIFF" | grep -q "Schema is synced"; then
            DIFF="No schema changes detected."
          fi

          echo "diff<<EOF" >> $GITHUB_OUTPUT
          echo "$DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment on PR
        uses: actions/github-script@v7
        env:
          DIFF_OUTPUT: ${{ steps.diff.outputs.diff }}
        with:
          script: |
            const diff = process.env.DIFF_OUTPUT;

            // å¤‰æ›´ãªã—ã®å ´åˆ
            if (diff.includes('No schema changes detected') || diff.includes('Schema is synced')) {
              const body = `## ğŸ—„ï¸ Atlas Schema Diff

            âœ… **å¤‰æ›´ãªã—** - ã‚¹ã‚­ãƒ¼ãƒã¯åŒæœŸæ¸ˆã¿ã§ã™

            ---
            *Generated by Atlas CI*`;

              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              const botComment = comments.find(c => c.body.includes('Atlas Schema Diff'));
              if (botComment) {
                await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body });
              } else {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body });
              }
              return;
            }

            // SQLæ–‡ã‚’æŠ½å‡º (-> ã§å§‹ã¾ã‚‹è¡Œ)
            const sqlStatements = [];
            const lines = diff.split('\n');
            let currentSql = '';
            let inSql = false;

            for (const line of lines) {
              if (line.trim().startsWith('->')) {
                inSql = true;
                currentSql = line.trim().substring(2).trim();
              } else if (inSql) {
                if (line.trim().startsWith('--') || line.trim() === '' || line.includes('---')) {
                  if (currentSql) {
                    sqlStatements.push(currentSql.trim().replace(/;$/, ''));
                    currentSql = '';
                  }
                  inSql = false;
                } else {
                  currentSql += '\n' + line;
                }
              }
            }
            if (currentSql) sqlStatements.push(currentSql.trim().replace(/;$/, ''));

            // é‡è¤‡ã‚’é™¤å»
            const uniqueSql = [...new Set(sqlStatements)];

            // ãƒ†ãƒ¼ãƒ–ãƒ«æƒ…å ±ã‚’æŠ½å‡º
            const changes = [];
            for (const sql of uniqueSql) {
              if (sql.includes('ALTER TABLE')) {
                const tableMatch = sql.match(/ALTER TABLE "public"\."(\w+)"/);
                const table = tableMatch ? tableMatch[1] : 'unknown';
                if (sql.includes('ADD COLUMN')) {
                  const colMatch = sql.match(/ADD COLUMN "(\w+)" ([^\s]+)/);
                  changes.push({ table, op: 'ADD COLUMN', detail: colMatch ? `${colMatch[1]} (${colMatch[2]})` : '' });
                } else if (sql.includes('DROP COLUMN')) {
                  const colMatch = sql.match(/DROP COLUMN "(\w+)"/);
                  changes.push({ table, op: 'DROP COLUMN', detail: colMatch ? colMatch[1] : '' });
                } else {
                  changes.push({ table, op: 'ALTER', detail: '' });
                }
              } else if (sql.includes('CREATE TABLE')) {
                const tableMatch = sql.match(/CREATE TABLE "public"\."(\w+)"/);
                changes.push({ table: tableMatch ? tableMatch[1] : 'unknown', op: 'CREATE TABLE', detail: '' });
              } else if (sql.includes('DROP TABLE')) {
                const tableMatch = sql.match(/DROP TABLE "public"\."(\w+)"/);
                changes.push({ table: tableMatch ? tableMatch[1] : 'unknown', op: 'DROP TABLE', detail: '' });
              }
            }

            // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
            let tableRows = changes.map(c => `| ${c.table} | ${c.op} | ${c.detail} |`).join('\n');
            if (!tableRows) tableRows = '| - | - | - |';

            const body = `## ğŸ—„ï¸ Atlas Schema Diff

            ğŸ“Š **${uniqueSql.length} ä»¶ã®å¤‰æ›´**

            | ãƒ†ãƒ¼ãƒ–ãƒ« | æ“ä½œ | å†…å®¹ |
            |---------|------|------|
            ${tableRows}

            <details>
            <summary>ğŸ“ SQL è©³ç´°</summary>

            \`\`\`sql
            ${uniqueSql.map(s => s + ';').join('\n\n')}
            \`\`\`

            </details>

            ---
            *Generated by Atlas CI*`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.body.includes('Atlas Schema Diff')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
